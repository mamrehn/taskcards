<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lernkarten App</title>
    <link rel="stylesheet" href="cards.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 id="app-title">Lernkarten App</h1>
            <p id="app-subtitle">Lade eine JSON-Datei oder ein ZIP Archiv von JSON-Dateien hoch - oder wähle ein gespeichertes Deck</p>
        </div>

        <div id="file-input-container">
            <div class="upload-options">
                <div class="upload-option">
                    <label for="file-input" id="upload-label">JSON hochladen</label>
                    <input type="file" id="file-input" accept=".json">
                </div>
                <div class="upload-option">
                    <label for="zip-input" id="zip-upload-label">oder ZIP hochladen</label>
                    <input type="file" id="zip-input" accept=".zip">
                </div>
            </div>
            <p><span class="json-toggle" onclick="toggleJsonSample()">JSON-Format Beispiel anzeigen</span></p>
            <div id="sample-json" class="hidden">
                {
  "cards": [
    {
      "question": "Was ist die Hauptstadt von Deutschland?",
      "answer": "Berlin"
    },
    {
      "question": "Was ist 2+2?",
      "answer": "4"
    },
    {
      "question": "Welche sind Primzahlen?",
      "options": ["2", "4", "7", "9", "11"],
      "correct": [0, 2, 4]
    }
  ]
}
            </div>

            <div id="saved-decks-container">
                <h3>Gespeicherte Decks</h3>
                <div id="deck-selection-controls">
                    <button id="start-selected-decks" class="btn btn-primary" disabled>Mit ausgewählten Decks starten</button>
                    <button id="select-all-decks" class="btn btn-secondary">Alle auswählen</button>
                    <button id="deselect-all-decks" class="btn btn-secondary">Alle abwählen</button>
                </div>
                <div id="saved-decks">
                    <!-- Saved decks will be dynamically inserted here -->
                </div>
            </div>
        </div>

        <div id="app-content" class="hidden">
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="cards-remaining">0</div>
                    <div class="stat-label">Verbleibend</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="cards-completed">0</div>
                    <div class="stat-label">Bearbeitet</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="correct-count">0</div>
                    <div class="stat-label">Richtig</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="incorrect-count">0</div>
                    <div class="stat-label">Falsch</div>
                </div>
            </div>

            <div class="progress-bar">
                <div class="progress" id="progress-bar"></div>
            </div>

            <div class="card-container" id="card-container">
                <div class="card" id="flip-card">
                    <div class="card-front">
                        <div class="card-content">
                            <div class="question" id="question-text">Frage erscheint hier</div>
                            <!-- Text input for standard questions -->
                            <input type="text" class="user-answer-input" id="user-answer-input"
                                placeholder="Deine Antwort...">

                            <!-- Multiple choice options container -->
                            <div id="options-container" class="options-container hidden">
                                <!-- Options will be dynamically inserted here -->
                            </div>
                        </div>
                        <div class="controls">
                            <button class="btn btn-primary" id="show-answer">Antwort zeigen</button>
                        </div>
                    </div>
                    <div class="card-back">
                        <div class="card-content">
                            <div class="question" id="question-back">Frage erscheint hier</div>
                            <div class="source-deck" id="source-deck-display"></div>

                            <!-- Text answer display -->
                            <div id="user-answer-container" class="hidden">
                                <div class="user-answer-display">
                                    <strong>Deine Antwort:</strong>
                                    <div id="user-answer-display"></div>
                                </div>
                            </div>

                            <!-- Multiple choice answer display -->
                            <div id="selected-options-container" class="hidden">
                                <div class="selected-options-display">
                                    <strong>Deine Auswahl:</strong>
                                    <div id="selected-options-display"></div>
                                </div>
                            </div>

                            <!-- Standard answer display -->
                            <div id="standard-answer-container">
                                <div class="answer" id="answer-text">Antwort erscheint hier</div>
                            </div>

                            <!-- Multiple choice correct answer display -->
                            <div id="mc-correct-answer-container" class="hidden">
                                <div class="answer">
                                    <strong>Korrekte Antworten:</strong>
                                    <div id="mc-correct-answer-text"></div>
                                </div>
                            </div>
                        </div>
                        <div class="controls">
                            <button class="btn btn-success" id="mark-correct">Richtig</button>
                            <button class="btn btn-danger" id="mark-incorrect">Falsch</button>
                            <button class="btn btn-secondary" id="next-card">Nächste</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="feedback hidden" id="feedback">
                <h2>Quiz abgeschlossen!</h2>
                <div id="overall-stats">
                    <p>Gesamtergebnis: <span id="final-score">0%</span></p>
                </div>
                <div id="deck-stats-container">
                    <!-- Individual deck statistics will appear here -->
                </div>
                <div style="margin-top: 1rem;">
                    <button class="btn btn-primary" id="restart-btn">Neu starten</button>
                    <button class="btn btn-secondary" id="upload-new-btn">Neues Deck</button>
                </div>
            </div>

            <div id="error-message" class="error-message hidden"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // Global variables
        let cards = [];
        let currentCardIndex = 0;
        let correctCount = 0;
        let incorrectCount = 0;
        let answeredCards = [];
        let isAnswered = false;
        let activeDecks = []; // Array of deck names that are currently active
        let savedDecks = {};
        let previousIncorrectIndices = {};
        let selectedOptionIndices = []; // For multiple choice questions
        let deckStats = {}; // For tracking per-deck statistics

        // DOM elements
        const fileInput = document.getElementById('file-input');
        const zipInput = document.getElementById('zip-input');
        const appContent = document.getElementById('app-content');
        const appTitle = document.getElementById('app-title');
        const appSubtitle = document.getElementById('app-subtitle');
        const questionText = document.getElementById('question-text');
        const questionBack = document.getElementById('question-back');
        const sourceDeckDisplay = document.getElementById('source-deck-display');
        const answerText = document.getElementById('answer-text');
        const userAnswerInput = document.getElementById('user-answer-input');
        const userAnswerContainer = document.getElementById('user-answer-container');
        const userAnswerDisplay = document.getElementById('user-answer-display');
        const optionsContainer = document.getElementById('options-container');
        const selectedOptionsContainer = document.getElementById('selected-options-container');
        const selectedOptionsDisplay = document.getElementById('selected-options-display');
        const mcCorrectAnswerContainer = document.getElementById('mc-correct-answer-container');
        const mcCorrectAnswerText = document.getElementById('mc-correct-answer-text');
        const standardAnswerContainer = document.getElementById('standard-answer-container');
        const showAnswerBtn = document.getElementById('show-answer');
        const markCorrectBtn = document.getElementById('mark-correct');
        const markIncorrectBtn = document.getElementById('mark-incorrect');
        const nextCardBtn = document.getElementById('next-card');
        const progressBar = document.getElementById('progress-bar');
        const cardsRemainingElement = document.getElementById('cards-remaining');
        const cardsCompletedElement = document.getElementById('cards-completed');
        const correctCountElement = document.getElementById('correct-count');
        const incorrectCountElement = document.getElementById('incorrect-count');
        const feedbackElement = document.getElementById('feedback');
        const finalScoreElement = document.getElementById('final-score');
        const deckStatsContainer = document.getElementById('deck-stats-container');
        const restartBtn = document.getElementById('restart-btn');
        const uploadNewBtn = document.getElementById('upload-new-btn');
        const errorMessageElement = document.getElementById('error-message');
        const flipCard = document.getElementById('flip-card');
        const cardContainer = document.getElementById('card-container');
        const savedDecksContainer = document.getElementById('saved-decks');
        const startSelectedDecksBtn = document.getElementById('start-selected-decks');
        const selectAllDecksBtn = document.getElementById('select-all-decks');
        const deselectAllDecksBtn = document.getElementById('deselect-all-decks');

        // Event listeners
        fileInput.addEventListener('change', handleFileUpload);
        zipInput.addEventListener('change', handleZipUpload);
        showAnswerBtn.addEventListener('click', showAnswer);
        markCorrectBtn.addEventListener('click', () => markAnswer(true));
        markIncorrectBtn.addEventListener('click', () => markAnswer(false));
        nextCardBtn.addEventListener('click', showNextCard);
        restartBtn.addEventListener('click', restartQuiz);
        uploadNewBtn.addEventListener('click', resetAndUpload);
        startSelectedDecksBtn.addEventListener('click', startSelectedDecks);
        selectAllDecksBtn.addEventListener('click', selectAllDecks);
        deselectAllDecksBtn.addEventListener('click', deselectAllDecks);

        // Hide the next button initially
        nextCardBtn.style.display = 'none';

        // Load saved decks from local storage on page load
        window.addEventListener('DOMContentLoaded', () => {
            loadSavedDecks();
            displaySavedDecks();
        });

        // Functions
        function toggleJsonSample() {
            const sampleJson = document.getElementById('sample-json');
            sampleJson.classList.toggle('hidden');
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
                showError('Bitte lade eine gültige JSON-Datei hoch.');
                return;
            }

            processJsonFile(file);
        }

        function handleZipUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.type !== 'application/zip' && !file.name.endsWith('.zip')) {
                showError('Bitte lade eine gültige ZIP-Datei hoch.');
                return;
            }

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const zip = new JSZip();
                    const zipContent = await zip.loadAsync(e.target.result);
                    let processedCount = 0;
                    let errorCount = 0;

                    // Process each file in the ZIP
                    const promises = [];
                    zipContent.forEach((relativePath, zipEntry) => {
                        if (!zipEntry.dir && relativePath.endsWith('.json')) {
                            const promise = zipEntry.async('string').then(content => {
                                try {
                                    const data = JSON.parse(content);
                                    
                                    if (!data.cards || !Array.isArray(data.cards) || data.cards.length === 0) {
                                        errorCount++;
                                        return;
                                    }

                                    // Check card validity
                                    const validCards = validateCards(data.cards);
                                    
                                    if (validCards.length === 0) {
                                        errorCount++;
                                        return;
                                    }

                                    // Save the deck with filename as deck name
                                    const deckName = relativePath.split('/').pop().replace('.json', '');
                                    saveToLocalStorage(deckName, validCards, []);
                                    processedCount++;
                                } catch (e) {
                                    errorCount++;
                                }
                            });
                            promises.push(promise);
                        }
                    });

                    await Promise.all(promises);
                    
                    if (processedCount > 0) {
                        displaySavedDecks();
                        showMessage(`${processedCount} Decks erfolgreich importiert${errorCount > 0 ? `, ${errorCount} fehlgeschlagen` : ''}.`);
                    } else {
                        showError('Keine gültigen JSON-Dateien in der ZIP-Datei gefunden.');
                    }
                    
                    // Reset the file input
                    zipInput.value = '';
                } catch (error) {
                    showError('Fehler beim Entpacken der ZIP-Datei.');
                    console.error(error);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function processJsonFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    if (!data.cards || !Array.isArray(data.cards) || data.cards.length === 0) {
                        showError('Ungültiges JSON-Format. Bitte stelle sicher, dass deine Datei ein "cards" Array mit mindestens einer Karte enthält.');
                        return;
                    }

                    // Validate cards
                    const validCards = validateCards(data.cards);

                    if (validCards.length === 0) {
                        showError('Keine gültigen Karten gefunden. Jede Karte muss entweder ein "question" und ein "answer" Feld ODER ein "question", "options" und "correct" Feld haben.');
                        return;
                    }

                    // Save the deck to local storage
                    const deckName = file.name.replace('.json', '');
                    activeDecks = [deckName]; // Set as the only active deck

                    // Update the app title with the deck name
                    updateAppTitle([deckName]);

                    // Save to local storage
                    saveToLocalStorage(deckName, validCards, []);
                    displaySavedDecks();

                    // Initialize the quiz with the loaded cards
                    initializeQuiz(validCards.map(card => ({...card, sourceDeck: deckName})));
                    
                    // Reset the file input
                    fileInput.value = '';
                } catch (error) {
                    showError('Fehler beim Parsen der JSON-Datei. Bitte überprüfe das Dateiformat.');
                    console.error(error);
                }
            };
            reader.readAsText(file);
        }

        function validateCards(cards) {
            return cards.filter(card => {
                // Check standard card format
                if (card.question && card.answer) {
                    return true;
                }
                // Check multiple choice format
                if (card.question && Array.isArray(card.options) && card.options.length > 0 &&
                    Array.isArray(card.correct) && card.correct.length > 0) {
                    return true;
                }
                return false;
            });
        }

        function updateAppTitle(deckNames) {
            if (deckNames.length === 1) {
                appTitle.textContent = `Lernkarten App - ${deckNames[0]}`;
            } else {
                appTitle.textContent = `Lernkarten App - ${deckNames.length} Decks kombiniert`;
            }
            // Hide the subtitle when a deck is active
            appSubtitle.style.display = 'none';
        }

        function loadSavedDecks() {
            const savedDecksString = localStorage.getItem('flashcardDecks');
            if (savedDecksString) {
                savedDecks = JSON.parse(savedDecksString);
            }
            
            const incorrectIndicesString = localStorage.getItem('flashcardIncorrectIndices');
            if (incorrectIndicesString) {
                previousIncorrectIndices = JSON.parse(incorrectIndicesString);
            }
        }

        function saveToLocalStorage(deckName, deckCards, incorrectIndices = []) {
            savedDecks[deckName] = {
                cards: deckCards
            };
            localStorage.setItem('flashcardDecks', JSON.stringify(savedDecks));
            
            // Save incorrect indices separately
            if (!previousIncorrectIndices[deckName]) {
                previousIncorrectIndices[deckName] = [];
            }
            if (incorrectIndices.length > 0) {
                previousIncorrectIndices[deckName] = [...incorrectIndices];
            }
            localStorage.setItem('flashcardIncorrectIndices', JSON.stringify(previousIncorrectIndices));
        }

        function updateIncorrectIndices() {
            localStorage.setItem('flashcardIncorrectIndices', JSON.stringify(previousIncorrectIndices));
        }

        function displaySavedDecks() {
            const savedDecksDiv = document.getElementById('saved-decks');
            savedDecksDiv.innerHTML = '';

            if (Object.keys(savedDecks).length === 0) {
                const noDecksMessage = document.createElement('p');
                noDecksMessage.textContent = 'Keine gespeicherten Decks gefunden.';
                savedDecksDiv.appendChild(noDecksMessage);
                startSelectedDecksBtn.disabled = true;
                return;
            }

            for (const deckName in savedDecks) {
                const deckElement = document.createElement('div');
                deckElement.className = 'saved-deck';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `deck-checkbox-${deckName}`;
                checkbox.className = 'deck-checkbox';
                checkbox.dataset.deckName = deckName;
                checkbox.addEventListener('change', updateStartButtonState);

                const deckTitle = document.createElement('label');
                deckTitle.className = 'deck-title';
                deckTitle.htmlFor = `deck-checkbox-${deckName}`;
                deckTitle.textContent = `${deckName} (${savedDecks[deckName].cards.length} Karten)`;

                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-deck';
                deleteButton.textContent = '×';
                deleteButton.title = 'Deck löschen';
                deleteButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteSavedDeck(deckName);
                });

                deckElement.appendChild(checkbox);
                deckElement.appendChild(deckTitle);
                deckElement.appendChild(deleteButton);
                savedDecksDiv.appendChild(deckElement);
            }
            
            updateStartButtonState();
        }

        function updateStartButtonState() {
            const checkboxes = document.querySelectorAll('.deck-checkbox:checked');
            startSelectedDecksBtn.disabled = checkboxes.length === 0;
        }

        function startSelectedDecks() {
            const selectedCheckboxes = document.querySelectorAll('.deck-checkbox:checked');
            if (selectedCheckboxes.length === 0) return;

            const selectedDeckNames = Array.from(selectedCheckboxes).map(cb => cb.dataset.deckName);
            activeDecks = selectedDeckNames;

            // Update the app title
            updateAppTitle(selectedDeckNames);

            // Merge selected decks
            let mergedCards = [];
            selectedDeckNames.forEach(deckName => {
                if (savedDecks[deckName]) {
                    const cardsWithSource = savedDecks[deckName].cards.map(card => ({
                        ...card,
                        sourceDeck: deckName
                    }));
                    mergedCards = [...mergedCards, ...cardsWithSource];
                }
            });

            // Initialize statistics tracking for each deck
            resetDeckStats(selectedDeckNames);

            // Initialize the quiz with merged cards
            initializeQuiz(mergedCards);
        }

        function resetDeckStats(deckNames) {
            deckStats = {};
            deckNames.forEach(deckName => {
                deckStats[deckName] = {
                    correct: 0,
                    incorrect: 0,
                    total: savedDecks[deckName].cards.length
                };
            });
        }

        function selectAllDecks() {
            const checkboxes = document.querySelectorAll('.deck-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = true;
            });
            updateStartButtonState();
        }

        function deselectAllDecks() {
            const checkboxes = document.querySelectorAll('.deck-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = false;
            });
            updateStartButtonState();
        }

        function deleteSavedDeck(deckName) {
            if (confirm(`Möchtest du das Deck "${deckName}" wirklich löschen?`)) {
                delete savedDecks[deckName];
                localStorage.setItem('flashcardDecks', JSON.stringify(savedDecks));
                
                if (previousIncorrectIndices[deckName]) {
                    delete previousIncorrectIndices[deckName];
                    localStorage.setItem('flashcardIncorrectIndices', JSON.stringify(previousIncorrectIndices));
                }
                
                displaySavedDecks();
            }
        }

        function initializeQuiz(loadedCards) {
            // Reset the quiz state
            cards = loadedCards;
            currentCardIndex = 0;
            correctCount = 0;
            incorrectCount = 0;
            answeredCards = new Array(cards.length).fill(null);

            // Prioritize incorrectly answered cards if available
            prioritizeIncorrectCards();

            // Show the app content
            document.getElementById('file-input-container').style.display = 'none';
            appContent.classList.remove('hidden');

            // Update UI
            updateStatistics();
            showCurrentCard();
        }

        function prioritizeIncorrectCards() {
            if (activeDecks.length === 0) return;
            
            // Create a copy of the cards array for manipulation
            const allCards = [...cards];
            const prioritizedCards = [];
            const remainingCards = [];
            
            // First, identify cards from decks with incorrect answers
            allCards.forEach(card => {
                const deckName = card.sourceDeck;
                if (previousIncorrectIndices[deckName] && previousIncorrectIndices[deckName].length > 0) {
                    // Find if this card was incorrect in its original deck
                    const originalIndex = savedDecks[deckName].cards.findIndex(c => 
                        c.question === card.question && 
                        (c.answer === card.answer || 
                         (Array.isArray(c.options) && Array.isArray(card.options) && 
                          JSON.stringify(c.options) === JSON.stringify(card.options)))
                    );
                    
                    if (originalIndex !== -1 && previousIncorrectIndices[deckName].includes(originalIndex)) {
                        prioritizedCards.push(card);
                    } else {
                        remainingCards.push(card);
                    }
                } else {
                    remainingCards.push(card);
                }
            });

            // Shuffle both arrays
            shuffleArray(prioritizedCards);
            shuffleArray(remainingCards);

            // Combine the arrays
            cards = [...prioritizedCards, ...remainingCards];
        }

        function shuffleCards() {
            shuffleArray(cards);
        }

        function shuffleArray(array) {
            // Fisher-Yates shuffle algorithm
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function showCurrentCard() {
            if (currentCardIndex >= cards.length) {
                showFeedback();
                return;
            }

            isAnswered = false;
            selectedOptionIndices = []; // Reset selected options
            const card = cards[currentCardIndex];

            // Make sure the card is not flipped when showing a new card
            flipCard.classList.remove('flipped');
            
            // Set question on both sides
            questionText.textContent = card.question;
            questionBack.textContent = card.question;
            
            // Show source deck info
            sourceDeckDisplay.textContent = `Quelle: ${card.sourceDeck}`;

            // Check if current card is multiple choice or standard
            const isMultipleChoice = Array.isArray(card.options) && card.options.length > 0;

            if (isMultipleChoice) {
                // Handle multiple choice question
                userAnswerInput.classList.add('hidden');
                optionsContainer.classList.remove('hidden');
                showAnswerBtn.classList.remove('hidden');

                // Clear previous options
                optionsContainer.innerHTML = '';

                // Create a copy of options array for shuffling
                const shuffledOptions = [...card.options];
                // Create a mapping to track original indices after shuffling
                const optionMapping = shuffledOptions.map((_, index) => index);

                // Shuffle options
                for (let i = shuffledOptions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffledOptions[i], shuffledOptions[j]] = [shuffledOptions[j], shuffledOptions[i]];
                    [optionMapping[i], optionMapping[j]] = [optionMapping[j], optionMapping[i]];
                }

                // Create option items with shuffled order
                shuffledOptions.forEach((option, index) => {
                    const originalIndex = optionMapping[index];
                    const optionItem = document.createElement('div');
                    optionItem.className = 'option-item';
                    optionItem.dataset.index = originalIndex;

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'option-checkbox';
                    checkbox.id = `option-${index}`;

                    const label = document.createElement('label');
                    label.htmlFor = `option-${index}`;
                    label.textContent = option;

                    optionItem.appendChild(checkbox);
                    optionItem.appendChild(label);

                    // Add click handler to toggle selection
                    optionItem.addEventListener('click', (e) => {
                        checkbox.checked = !checkbox.checked;

                        optionItem.classList.toggle('selected', checkbox.checked);

                        // Update selectedOptionIndices
                        if (checkbox.checked) {
                            if (!selectedOptionIndices.includes(originalIndex)) {
                                selectedOptionIndices.push(originalIndex);
                            }
                        } else {
                            const indexToRemove = selectedOptionIndices.indexOf(originalIndex);
                            if (indexToRemove !== -1) {
                                selectedOptionIndices.splice(indexToRemove, 1);
                            }
                        }
                    });

                    optionsContainer.appendChild(optionItem);
                });

                // Set answer text for back of card
                standardAnswerContainer.classList.add('hidden');
                mcCorrectAnswerContainer.classList.remove('hidden');

                // Display correct answers
                const correctIndices = card.correct;
                mcCorrectAnswerText.innerHTML = correctIndices.map(index => {
                    return `<div>- ${card.options[index]}</div>`;
                }).join('');

            } else {
                // Handle standard question
                userAnswerInput.classList.remove('hidden');
                optionsContainer.classList.add('hidden');
                showAnswerBtn.classList.remove('hidden');

                // Reset user answer input
                userAnswerInput.value = '';
                userAnswerInput.readOnly = false;

                // Set answer text for standard card
                answerText.textContent = card.answer;
                standardAnswerContainer.classList.remove('hidden');
                mcCorrectAnswerContainer.classList.add('hidden');
            }

            // Reset containers
            userAnswerContainer.classList.add('hidden');
            selectedOptionsContainer.classList.add('hidden');

            // Reset buttons
            markCorrectBtn.style.display = 'inline-block';
            markIncorrectBtn.style.display = 'inline-block';
            nextCardBtn.style.display = 'none';

            updateStatistics();
        }

        function showAnswer() {
            flipCard.classList.add('flipped');
        
            const card = cards[currentCardIndex];
            const isMultipleChoice = Array.isArray(card.options) && Array.isArray(card.correct);
        
            if (isMultipleChoice) {
                // For multiple choice questions
                if (selectedOptionIndices.length > 0) {
                    // Check if the answer is correct
                    const isCorrect = arraysEqual(selectedOptionIndices.sort(), card.correct.sort());
                    
                    if (isCorrect) {
                        // If correct, don't show user's answer, just keep showing the correct answers
                        selectedOptionsContainer.classList.add('hidden');
                    } else {
                        // If incorrect, show what the user selected
                        selectedOptionsDisplay.innerHTML = selectedOptionIndices.map(index => {
                            return `<div>- ${card.options[index]}</div>`;
                        }).join('');
                        selectedOptionsContainer.classList.remove('hidden');
                    }
                    
                    // Auto-evaluate the answer
                    markAnswer(isCorrect);
                    
                    // For multiple choice with selections, directly show Next button only
                    markCorrectBtn.style.display = 'none';
                    markIncorrectBtn.style.display = 'none';
                    nextCardBtn.style.display = 'inline-block';
                } else {
                    // No selection was made, still let user decide if they knew answer
                    selectedOptionsContainer.classList.add('hidden');
                    
                    // Show the evaluation buttons for no selection case
                    markCorrectBtn.style.display = 'inline-block';
                    markIncorrectBtn.style.display = 'inline-block';
                    nextCardBtn.style.display = 'none';
                }
            } else {
                // Handle standard text answer display
                const userAnswer = userAnswerInput.value.trim();
                if (userAnswer) {
                    userAnswerDisplay.textContent = userAnswer;
                    userAnswerContainer.classList.remove('hidden');
                } else {
                    userAnswerContainer.classList.add('hidden');
                }
                
                // For text answers, show the Richtig/Falsch buttons
                markCorrectBtn.style.display = 'inline-block';
                markIncorrectBtn.style.display = 'inline-block';
                nextCardBtn.style.display = 'none';
            }
        }
        
        // Helper function to compare arrays
        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }

        function markAnswer(isCorrect) {
            if (isAnswered) return;

            isAnswered = true;
            answeredCards[currentCardIndex] = isCorrect;
            const card = cards[currentCardIndex];
            const deckName = card.sourceDeck;

            if (isCorrect) {
                correctCount++;
                if (deckStats[deckName]) {
                    deckStats[deckName].correct++;
                }
            } else {
                incorrectCount++;
                if (deckStats[deckName]) {
                    deckStats[deckName].incorrect++;
                }
                
                // Store the incorrect card in the source deck's incorrect indices
                if (deckName && savedDecks[deckName]) {
                    // Find original index in the source deck
                    const originalDeckCards = savedDecks[deckName].cards;
                    const originalIndex = originalDeckCards.findIndex(c => 
                        c.question === card.question && 
                        (c.answer === card.answer || 
                        (Array.isArray(c.options) && Array.isArray(card.options) && 
                        JSON.stringify(c.options) === JSON.stringify(card.options)))
                    );
                    
                    if (originalIndex !== -1) {
                        if (!previousIncorrectIndices[deckName]) {
                            previousIncorrectIndices[deckName] = [];
                        }
                        if (!previousIncorrectIndices[deckName].includes(originalIndex)) {
                            previousIncorrectIndices[deckName].push(originalIndex);
                        }
                    }
                }
            }

            // Update incorrect indices in local storage
            updateIncorrectIndices();

            // Hide the evaluation buttons and show next button
            markCorrectBtn.style.display = 'none';
            markIncorrectBtn.style.display = 'none';
            nextCardBtn.style.display = 'inline-block';

            // If this was a multiple choice question, highlight correct/incorrect options
            if (Array.isArray(card.options) && Array.isArray(card.correct)) {
                const optionItems = document.querySelectorAll('.option-item');

                optionItems.forEach(item => {
                    const optionIndex = parseInt(item.dataset.index);
                    const isOptionCorrect = card.correct.includes(optionIndex);
                    const isOptionSelected = selectedOptionIndices.includes(optionIndex);

                    // First remove any existing styling classes
                    item.classList.remove('correct', 'incorrect');

                    // Add appropriate styling
                    if (isOptionCorrect) {
                        item.classList.add('correct');
                    } else if (isOptionSelected) {
                        item.classList.add('incorrect');
                    }
                });
            }

            updateStatistics();
        }

        function showNextCard() {
            currentCardIndex++;
            showCurrentCard();
        }

        function updateStatistics() {
            const totalCards = cards.length;
            const completedCards = correctCount + incorrectCount;
            const remainingCards = totalCards - completedCards;
            const percentageComplete = totalCards > 0 ? (completedCards / totalCards) * 100 : 0;

            cardsRemainingElement.textContent = remainingCards;
            cardsCompletedElement.textContent = completedCards;
            correctCountElement.textContent = correctCount;
            incorrectCountElement.textContent = incorrectCount;

            progressBar.style.width = `${percentageComplete}%`;
        }

        function showFeedback() {
            const totalAnswered = correctCount + incorrectCount;
            const percentageCorrect = totalAnswered > 0 ? Math.round((correctCount / totalAnswered) * 100) : 0;

            finalScoreElement.textContent = `${percentageCorrect}%`;
            feedbackElement.classList.remove('hidden');
            cardContainer.classList.add('hidden');

            // Display per-deck statistics
            deckStatsContainer.innerHTML = '';
            
            if (activeDecks.length > 1) {
                const deckStatsHeader = document.createElement('h3');
                deckStatsHeader.textContent = 'Statistik pro Deck:';
                deckStatsContainer.appendChild(deckStatsHeader);
                
                const deckStatsList = document.createElement('div');
                deckStatsList.className = 'deck-stats-list';
                
                for (const deckName in deckStats) {
                    const stats = deckStats[deckName];
                    const totalAnswered = stats.correct + stats.incorrect;
                    
                    if (totalAnswered === 0) continue;
                    
                    const deckAccuracy = Math.round((stats.correct / totalAnswered) * 100);
                    
                    const deckStatItem = document.createElement('div');
                    deckStatItem.className = 'deck-stat-item';
                    deckStatItem.innerHTML = `
                        <strong>${deckName}:</strong> 
                        ${stats.correct} richtig, 
                        ${stats.incorrect} falsch, 
                        ${deckAccuracy}% Genauigkeit
                    `;
                    
                    deckStatsList.appendChild(deckStatItem);
                }
                
                deckStatsContainer.appendChild(deckStatsList);
            }
        }

        function restartQuiz() {
            currentCardIndex = 0;
            correctCount = 0;
            incorrectCount = 0;

            // Reset deck statistics
            resetDeckStats(activeDecks);

            // Reset answered cards
            answeredCards = new Array(cards.length).fill(null);

            // Prioritize incorrect cards again and reshuffle
            shuffleCards();
            prioritizeIncorrectCards();

            // Reset UI
            feedbackElement.classList.add('hidden');
            cardContainer.classList.remove('hidden');
            updateStatistics();
            showCurrentCard();
        }

        function resetAndUpload() {
            // Reset everything and show file upload
            document.getElementById('file-input-container').style.display = 'block';
            appContent.classList.add('hidden');
            feedbackElement.classList.add('hidden');
            cardContainer.classList.remove('hidden');
            fileInput.value = '';
            zipInput.value = '';

            // Reset the app title
            appTitle.textContent = 'Lernkarten App';
            appSubtitle.style.display = 'block';

            // Clear any error messages
            errorMessageElement.classList.add('hidden');
            errorMessageElement.textContent = '';

            // Display saved decks
            displaySavedDecks();
        }

        function showError(message) {
            errorMessageElement.textContent = message;
            errorMessageElement.classList.remove('hidden');
            setTimeout(() => {
                errorMessageElement.classList.add('hidden');
            }, 5000);
        }

        function showMessage(message) {
            const messageEl = document.createElement('div');
            messageEl.className = 'message-popup';
            messageEl.textContent = message;
            document.body.appendChild(messageEl);
            
            setTimeout(() => {
                messageEl.classList.add('show');
            }, 10);
            
            setTimeout(() => {
                messageEl.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(messageEl);
                }, 300);
            }, 3000);
        }
    </script>
</body>
</html>
                
