<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Quiz</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <link rel="stylesheet" href="qlash.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>Multiplayer Quiz</h1>
            <p>Clash of Questions</p>
        </header>

        <div id="role-selection" class="view active card">
            <h2>Wählen deine Rolle</h2>
            <button id="host-btn" class="btn">Quiz hosten</button>
            <button id="player-btn" class="btn">Quiz beitreten</button>
        </div>

        <div id="host-view" class="view card">
            <h2 id="host-view-heading">Quiz hosten</h2>

            <div id="host-setup">
                <div class="duration-setting" style="margin-top: 15px;">
                    <label for="question-duration-input">Fragedauer (Sekunden):</label>
                    <input type="number" id="question-duration-input" value="20" min="5" max="60" class="w-full p-2 border rounded">
                </div>
                <button id="start-quiz-btn" class="btn btn-accent" style="margin-top: 10px;">Quiz starten</button>

                <div class="file-input-container">
                    <label for="json-file" class="file-input-label">Fragen importieren (JSON)</label>
                    <input type="file" id="json-file" accept=".json">
                </div>
                <p id="file-status"></p>

                <h3>Oder Fragen manuell erstellen:</h3>
                <form id="question-form">
                    <div>
                        <label for="question-text">Frage:</label>
                        <input type="text" id="question-text" placeholder="Gib deine Frage ein">
                    </div>
                    <div class="option-group">
                        <input type="text" class="option-input" placeholder="Option 1">
                        <input type="checkbox" class="correct-checkbox">
                        <label>Richtig</label>
                    </div>
                    <div class="option-group">
                        <input type="text" class="option-input" placeholder="Option 2">
                        <input type="checkbox" class="correct-checkbox">
                        <label>Richtig</label>
                    </div>
                    <button type="button" id="add-option-btn" class="btn">Option hinzufügen</button>
                    <button type="submit" class="btn">Frage hinzufügen</button>
                </form>

                <div id="questions-list">
                    <h3>Hinzugefügte Fragen:</h3>
                    <div id="questions-container">
                        <p>Noch keine Fragen hinzugefügt</p>
                    </div>
                </div>
            </div>

            <div id="qr-container" class="hidden">
                <h3>Diesen Link oder QR-Code teilen, damit Spieler beitreten können:</h3>
                <div id="qrcode" style="cursor: pointer;"></div>
                <p>Beitrittslink: <a id="join-link" href="#" target="_blank"></a></p>
                <p>Raum-Code: <span id="room-id"></span></p>
                <p>Verbundene Spieler: <span id="player-count">0</span></p>
                <div class="players-list" id="players-list"></div>
                <button id="start-questions-btn" class="btn btn-accent hidden">Fragen starten</button>
            </div>

            <div id="host-question-display" class="hidden">
                <h3 id="current-question-text"></h3>
                 <ul id="host-current-options" class="host-options-list"></ul>
                <div class="question-counter" id="question-counter"></div>
                <div class="timer-bar-container">
                    <div class="timer-bar" id="timer-bar"></div>
                </div>
                <p>Spieler haben geantwortet: <span id="answers-count">0</span>/<span id="total-players">0</span></p>
                 <div id="host-scoreboard" class="scoreboard hidden">
                    <h4>Aktuelle Rangliste (Top 10)</h4>
                    <ol id="scoreboard-list"></ol>
                </div>
                <button id="show-next-btn" class="btn hidden">Nächste Frage</button>
                <button id="show-results-btn" class="btn hidden">Endergebnisse anzeigen</button>
            </div>

            <div id="host-results" class="view card hidden">
                <h3>Endgültige Rangliste</h3>
                <div id="leaderboard"></div>
                <button id="new-quiz-btn" class="btn">Neues Quiz hosten</button>
            </div>
        </div>

        <div id="player-view" class="view card">
            <div id="join-form">
                <h2>Einem Quiz beitreten</h2>
                 <input type="text" id="room-code-input" placeholder="Host-ID eingeben oder QR scannen">
                <input type="text" id="player-name-input" placeholder="Dein Name">
                <button id="join-btn" class="btn">Quiz beitreten</button>
                <p>Oder scanne den vom Host bereitgestellten QR-Code</p>
            </div>

            <div id="waiting-room" class="hidden">
                <h2>Warten auf den Quizstart</h2>
                <p id="waiting-message">Du bist dem Raum erfolgreich beigetreten!</p>
                <div class="loader"></div>
                <p>Der Host wird das Quiz bald starten...</p>
            </div>

            <div id="player-question" class="hidden">
                <h3 id="player-question-text"></h3>
                <div class="question-counter" id="player-question-counter"></div>
                <div class="timer-bar-container">
                    <div class="timer-bar" id="player-timer-bar"></div>
                </div>
                <div id="options-container"></div>
                <button id="submit-answer-btn" class="btn hidden">Antwort absenden</button>
            </div>

            <div id="player-result" class="hidden">
                <div id="result-display"></div>
                <div class="score-display">Deine Punktzahl: <span id="player-score">0</span></div>
                <p id="waiting-for-next">Warten auf nächste Frage...</p>
            </div>

            <div id="player-final-result" class="view card hidden">
                <h2>Quiz beendet!</h2>
                <div id="player-leaderboard-container" style="margin-bottom: 15px;"></div>
                <div class="score-display">Deine Endpunktzahl: <span id="final-score">0</span></div>
                <p>Vielen Dank fürs Mitspielen!</p>
                <button id="play-again-btn" class="btn">Nochmal spielen</button>
            </div>
        </div>
    </div>

    <div id="qr-modal-overlay" class="qr-modal-overlay hidden">
        <div id="qr-modal-content" class="qr-modal-content">
            <button id="qr-modal-close" class="qr-modal-close">&times;</button>
            <h3>Zum Beitreten scannen</h3>
            <div id="large-qrcode"></div>
            <p>Beitrittslink: <a id="join-link-modal" href="#" target="_blank"></a></p>
            <p>Raum-Code: <span id="modal-room-id"></span></p>
        </div>
    </div>

    <div id="confetti-container"></div>

    <footer style="text-align: center; margin-top: 20px; font-size: 0.9em;">
        <p><a href="datenschutz.html" style="color: black; text-decoration: none;">Datenschutzhinweise</a></p>
    </footer>

    <script>
        // Supabase Konfiguration
        const SUPABASE_URL = 'https://psjanfchvdsefvzxqtac.supabase.co'; // ERSETZEN SIE DIES MIT IHRER SUPABASE PROJECT URL
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBzamFuZmNodmRzZWZ2enhxdGFjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc5ODYxMjMsImV4cCI6MjA2MzU2MjEyM30._VlPXwOCbwmG0ilFhNIJanPOEyDoOUY16PUyhswyMYY'; // ERSETZEN SIE DIES MIT IHREM SUPABASE ANON PUBLIC KEY

        const HOST_STORAGE_KEY = 'qlash_host_session_v1';
        const PLAYER_STORAGE_KEY = 'qlash_player_session_v1';

        // Declare supabaseClient globally
        let supabaseClient;

        // --- Utility functions ---
        /**
         * Displays a simple message to the user.
         * @param {string} message - The message to display.
         * @param {string} type - 'error' or 'info'.
         */
        function showMessage(message, type = 'info') {
            // For now, using alert for simplicity as a custom modal would add significant code.
            // In a real application, this would be replaced by a custom, non-blocking modal.
            console.log(`Message (${type}): ${message}`);
            alert(message); // Using alert as a temporary simple message box
        }

        /**
         * Shows a specific view and hides all other views.
         * @param {string} viewToShowId - The ID of the view element to show.
         */
        function showView(viewToShowId) {
            document.querySelectorAll('.view').forEach(view => view.classList.remove('active'));
            const viewElement = document.getElementById(viewToShowId);
            if (viewElement) viewElement.classList.add('active');
            else console.error("View not found:", viewToShowId);

            // Hide role selection buttons once a role is chosen
            if (viewToShowId === 'host-view' || viewToShowId === 'player-view') {
                document.getElementById('role-selection').classList.add('hidden');
            } else {
                document.getElementById('role-selection').classList.remove('hidden');
            }
        }

        /**
         * Generates a random alphanumeric ID of a specified length.
         * @param {number} length - The desired length of the ID.
         * @returns {string} The generated alphanumeric ID.
         */
        function generateAlphanumericId(length) {
            const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        /**
         * Shuffles an array in place using the Fisher-Yates (Knuth) algorithm.
         * @param {Array} array - The array to shuffle.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Swap elements
            }
        }

        // --- App initialization ---
        // QR Code Modal elements (declared globally for early access)
        let qrModalOverlay = null;
        let qrModalCloseBtn = null;
        let largeQrcodeContainer = null;
        let modalRoomIdSpan = null;

        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Supabase client here, after the DOM is loaded
            // This ensures the Supabase global object is available
            if (typeof supabase !== 'undefined' && supabase.createClient) {
                const { createClient } = supabase;
                supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            } else {
                console.error("Supabase library not loaded or 'supabase.createClient' is undefined. Please check network and script loading.");
                showMessage("Fehler: Die Supabase-Bibliothek konnte nicht geladen werden. Bitte überprüfe deine Internetverbindung oder versuche es später erneut.", 'error');
                return; // Prevent further execution if Supabase is not available
            }

            // Initialize QR modal elements as soon as DOM is ready
            qrModalOverlay = document.getElementById('qr-modal-overlay');
            qrModalCloseBtn = document.getElementById('qr-modal-close');
            largeQrcodeContainer = document.getElementById('large-qrcode');
            modalRoomIdSpan = document.getElementById('modal-room-id');

            // Event listener for closing the QR code modal when clicking the close button
            if (qrModalCloseBtn) {
                qrModalCloseBtn.addEventListener('click', () => {
                    if (qrModalOverlay) {
                        qrModalOverlay.classList.add('hidden');
                    }
                });
            }

            // Event listener for closing the QR code modal when clicking the overlay itself
            if (qrModalOverlay) {
                qrModalOverlay.addEventListener('click', (event) => {
                    // Only close if the click target is the overlay itself, not its children
                    if (event.target === qrModalOverlay) {
                        qrModalOverlay.classList.add('hidden');
                    }
                });
            }


            // Event listener for "Host a Quiz" button
            document.getElementById('host-btn').addEventListener('click', () => {
                showView('host-view');
                initializeHostFeatures();
            });
            // Event listener for "Join a Quiz" button
            document.getElementById('player-btn').addEventListener('click', () => {
                showView('player-view');
                initializePlayerFeatures();
            });

            // Check URL parameters for a host ID to auto-join on page load
            const urlParams = new URLSearchParams(window.location.search);
            const hostIdFromUrl = urlParams.get('host');

            if (hostIdFromUrl) {
                 // If host ID is in URL, navigate directly to player view and pre-fill
                 showView('player-view');
                 initializePlayerFeatures(); // Initialize player features first
                 document.getElementById('room-code-input').value = hostIdFromUrl;
            } else {
                 // Otherwise, check for saved sessions first, then show role selection
                 const savedPlayerSession = localStorage.getItem(PLAYER_STORAGE_KEY);
                 const savedHostSession = localStorage.getItem(HOST_STORAGE_KEY);
                 if (savedPlayerSession) {
                    showView('player-view');
                    initializePlayerFeatures();
                 } else if (savedHostSession) {
                    showView('host-view');
                    initializeHostFeatures();
                 } else {
                    showView('role-selection');
                 }
            }
        });

        // --- Host State & Initialization Flag ---
        let hostGlobalQuizState = null;
        let hostSupabaseChannel = null; // Supabase Broadcast Channel for host to send messages
        let hostPlayersSubscription = null; // Supabase Realtime subscription for player changes
        let isHostInitialized = false;
        let hostTimerInterval = null;
        let hostQuestionStartTime = null; // To track time for scoring
        let hostRoomId = null; // Stores the Supabase room ID
        let hostPlayerId = null; // Stores the host's own player ID
        let hostViewHeading = null; // Cached element for "Quiz hosten" heading

        async function resumeHostSession(sessionData) {
            console.log("Resuming host session:", sessionData);
            hostGlobalQuizState = sessionData.state;
            hostRoomId = sessionData.roomId;
            hostPlayerId = sessionData.playerId;
            isHostInitialized = false; // Force re-initialization of listeners
            await initializeHostFeatures(true); // Pass resume flag
        }

        /**
         * Initializes all features and event listeners for the host role.
         */
        async function initializeHostFeatures(isResuming = false) {
            // Check for a session to resume, but only if not already in a resume flow
            if (!isResuming) {
                const savedHostSession = localStorage.getItem(HOST_STORAGE_KEY);
                if (savedHostSession) {
                    if (confirm("Möchten Sie Ihre letzte Quiz-Sitzung fortsetzen?")) {
                        const sessionData = JSON.parse(savedHostSession);
                        await resumeHostSession(sessionData);
                        return; // Exit to avoid double initialization
                    } else {
                        localStorage.removeItem(HOST_STORAGE_KEY);
                        showView('role-selection');
                        return;
                    }
                }
            }

            console.log("Initializing Host Features. Initialized flag:", isHostInitialized);
            // Initialize quiz state if not already set
            if (!hostGlobalQuizState) {
                hostGlobalQuizState = {
                    currentQuestionIndex: 0,
                    questions: [], // Stores original questions
                    shuffledQuestions: [], // Stores shuffled questions for the current quiz session
                    players: {}, // Player structure includes score and answer time
                    answersReceived: 0,
                    isQuestionActive: false,
                    roomId: null, // This will be the 4-digit alphanumeric code
                    questionDuration: 20 // Default question duration in seconds
                };
            }

            const quizState = hostGlobalQuizState;
            // Cache DOM elements for performance
            const jsonFileInput = document.getElementById('json-file');
            const fileStatus = document.getElementById('file-status');
            const questionForm = document.getElementById('question-form');
            const questionText = document.getElementById('question-text');
            const addOptionBtn = document.getElementById('add-option-btn');
            const questionsContainer = document.getElementById('questions-container');
            const questionDurationInput = document.getElementById('question-duration-input');
            const startQuizBtn = document.getElementById('start-quiz-btn');
            const qrContainer = document.getElementById('qr-container');
            const hostSetup = document.getElementById('host-setup');
            const qrcodeElement = document.getElementById('qrcode');
            const roomIdElement = document.getElementById('room-id');
            const joinLinkElement = document.getElementById('join-link');
            const joinLinkModalElement = document.getElementById('join-link-modal');
            const playerCountElement = document.getElementById('player-count');
            const playersList = document.getElementById('players-list');
            const startQuestionsBtn = document.getElementById('start-questions-btn');
            const hostQuestionDisplay = document.getElementById('host-question-display');
            const currentQuestionTextEl = document.getElementById('current-question-text');
            const hostCurrentOptionsEl = document.getElementById('host-current-options');
            const questionCounterEl = document.getElementById('question-counter');
            const timerBar = document.getElementById('timer-bar');
            const answersCount = document.getElementById('answers-count');
            const totalPlayers = document.getElementById('total-players');
            const hostScoreboardEl = document.getElementById('host-scoreboard');
            const scoreboardListEl = document.getElementById('scoreboard-list');
            const showNextBtn = document.getElementById('show-next-btn');
            const showResultsBtn = document.getElementById('show-results-btn');
            const hostResults = document.getElementById('host-results');
            const leaderboard = document.getElementById('leaderboard');
            const newQuizBtn = document.getElementById('new-quiz-btn');
            hostViewHeading = document.getElementById('host-view-heading'); // Cache the heading

            // Set default duration input value
            questionDurationInput.value = quizState.questionDuration;

            // Only set up event listeners once
            if (!isHostInitialized) {
                console.log("Setting up host event listeners for the first time.");

                // Event listener for JSON file import
                jsonFileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            if (data && Array.isArray(data) && data.every(q => q.question && q.options && q.correct)) {
                                quizState.questions = data;
                            } else if (data && data.cards && Array.isArray(data.cards)) {
                                quizState.questions = data.cards;
                            } else {
                                fileStatus.textContent = 'Ungültiges JSON. Erwartet wird ein Array von Fragen oder eine "Karten"-Struktur.';
                                quizState.questions = [];
                            }
                            fileStatus.textContent = quizState.questions.length > 0 ? `Importiert ${quizState.questions.length} Fragen.` : (fileStatus.textContent || 'Keine Fragen im JSON gefunden.');
                            renderQuestionsList();
                        } catch (error) {
                            console.error('Error parsing JSON:', error);
                            fileStatus.textContent = 'Fehler beim Parsen des JSON. Format überprüfen.';
                            quizState.questions = [];
                            renderQuestionsList();
                        }
                    };
                    reader.readAsText(file);
                });

                // Event listener for adding new option input fields
                addOptionBtn.addEventListener('click', () => {
                    const optionGroups = questionForm.querySelectorAll('.option-group');
                    const newIndex = optionGroups.length + 1;
                    const optionGroup = document.createElement('div');
                    optionGroup.className = 'option-group';
                    optionGroup.innerHTML = `<input type="text" class="option-input" placeholder="Option ${newIndex}"><input type="checkbox" class="correct-checkbox"><label>Richtig</label></div>`;
                    questionForm.insertBefore(optionGroup, addOptionBtn);
                });

                // Event listener for submitting a new question
                questionForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const question = questionText.value.trim();
                    if (!question) {
                        showMessage('Bitte gebe eine Frage ein', 'error');
                        return;
                    }

                    const optionInputs = questionForm.querySelectorAll('.option-input');
                    const options = [];
                    const correct = [];

                    optionInputs.forEach((inputEl) => {
                        const optionText = inputEl.value.trim();
                        if (optionText) {
                            const currentIndex = options.length;
                            options.push(optionText);
                            const checkbox = inputEl.parentElement.querySelector('.correct-checkbox');
                            if (checkbox && checkbox.checked) {
                                correct.push(currentIndex);
                            }
                        }
                    });

                    if (options.length < 2) {
                        showMessage('Bitte füge mindestens zwei gültige Optionen hinzu', 'error');
                        return;
                    }
                    if (correct.length === 0) {
                        showMessage('Bitte wähle mindestens eine richtige Antwort aus', 'error');
                        return;
                    }

                    quizState.questions.push({ question, options, correct });
                    questionText.value = '';
                    questionForm.querySelectorAll('.option-group').forEach((group, index) => {
                        const input = group.querySelector('.option-input');
                        const checkbox = group.querySelector('.correct-checkbox');
                        if (index < 2) {
                            if(input) input.value = '';
                            if(checkbox) checkbox.checked = false;
                        } else {
                            group.remove();
                        }
                    });
                    renderQuestionsList();
                });

                // Event listener for starting the quiz
                startQuizBtn.addEventListener('click', async () => {
                    localStorage.removeItem(PLAYER_STORAGE_KEY); // Clear any lingering player session
                    if (quizState.questions.length === 0) {
                        showMessage('Bitte füge mindestens eine Frage hinzu.', 'error');
                        return;
                    }
                    const duration = parseInt(questionDurationInput.value, 10);
                    if (isNaN(duration) || duration < 5 || duration > 60) {
                        showMessage('Bitte gebe eine gültige Fragedauer zwischen 5 und 60 Sekunden ein.', 'error');
                        return;
                    }
                    quizState.questionDuration = duration;

                    // Shuffle questions once when quiz starts
                    quizState.shuffledQuestions = [...quizState.questions]; // Create a copy
                    shuffleArray(quizState.shuffledQuestions);

                    await initHostSupabase();
                });

                // Event listener for starting questions (after players join)
                startQuestionsBtn.addEventListener('click', async () => {
                    if (Object.keys(quizState.players).filter(pId => pId !== hostPlayerId).length === 0) { // Check only non-host players
                        showMessage("Es sind noch keine Spieler beigetreten!", 'info');
                        return;
                    }
                    qrContainer.classList.add('hidden');
                    hostQuestionDisplay.classList.remove('hidden');
                    if (hostViewHeading) hostViewHeading.classList.add('hidden'); // Hide "Quiz hosten" heading
                    quizState.currentQuestionIndex = 0;
                    await startQuestion();
                });

                // Event listener for moving to the next question
                showNextBtn.addEventListener('click', async () => {
                    quizState.currentQuestionIndex++;
                    await startQuestion();
                });

                // Event listener for showing final results
                showResultsBtn.addEventListener('click', showFinalResults);

                // Event listener for starting a new quiz
                newQuizBtn.addEventListener('click', async () => {
                    localStorage.removeItem(HOST_STORAGE_KEY); // Clear session
                    // Clean up Supabase subscriptions
                    if (hostSupabaseChannel) {
                        await supabaseClient.removeChannel(hostSupabaseChannel);
                        hostSupabaseChannel = null;
                    }
                    if (hostPlayersSubscription) {
                        await supabaseClient.removeChannel(hostPlayersSubscription);
                        hostPlayersSubscription = null;
                    }

                    // Remove room and players from DB
                    if (hostRoomId) {
                        await supabaseClient.from('players').delete().eq('room_id', hostRoomId); // Delete players first due to foreign key
                        await supabaseClient.from('rooms').delete().eq('id', hostRoomId);
                    }

                    hostGlobalQuizState = null;
                    isHostInitialized = false;
                    fileStatus.textContent = '';
                    if(jsonFileInput) jsonFileInput.value = '';
                    hostResults.classList.add('hidden');
                    hostQuestionDisplay.classList.add('hidden');
                    qrContainer.classList.add('hidden');
                    hostSetup.classList.remove('hidden');
                    document.getElementById('role-selection').classList.remove('hidden'); // Show role selection again
                    if (hostViewHeading) hostViewHeading.classList.remove('hidden'); // Show "Quiz hosten" heading
                    initializeHostFeatures(); // Re-initialize to reset UI fully
                });

                // Clean up Supabase subscriptions on window unload
                window.addEventListener('beforeunload', async () => {
                    // Save state on unload if we are a host and have a room
                    if (hostRoomId && hostGlobalQuizState) {
                        const sessionToSave = {
                            roomId: hostRoomId,
                            playerId: hostPlayerId,
                            state: hostGlobalQuizState
                        };
                        localStorage.setItem(HOST_STORAGE_KEY, JSON.stringify(sessionToSave));
                    }

                    if (hostSupabaseChannel) {
                        await supabaseClient.removeChannel(hostSupabaseChannel);
                    }
                    if (hostPlayersSubscription) {
                        await supabaseClient.removeChannel(hostPlayersSubscription);
                    }
                    // Optional: Mark host's player as disconnected or remove room
                    if (hostPlayerId) {
                        await supabaseClient.from('players').update({ is_connected: false }).eq('id', hostPlayerId);
                    }
                });

                // Event listener for opening the QR code modal
                qrcodeElement.addEventListener('click', () => {
                    if (qrModalOverlay && largeQrcodeContainer && hostRoomId) {
                        qrModalOverlay.classList.remove('hidden');
                        largeQrcodeContainer.innerHTML = ''; // Clear previous QR
                        new QRCode(largeQrcodeContainer, {
                            text: joinLinkElement.href, // Use the full join link
                            width: 300, // Larger size for modal
                            height: 300,
                            colorDark : "#000000",
                            colorLight : "#ffffff",
                            correctLevel : QRCode.CorrectLevel.H
                        });
                        modalRoomIdSpan.textContent = quizState.roomId; // Display the 4-digit room code in modal
                    }
                });

                isHostInitialized = true;
            }

            if (isResuming) {
                await initHostSupabase(true);
            }

            renderQuestionsList();
            updatePlayersList();

            // Logic to determine which host section to display on initialization/re-entry
            if(hostRoomId) { // Check if a room is already established
                const roomStatus = hostGlobalQuizState?.quiz_state?.status;
                if (roomStatus === 'ended') {
                    hostSetup.classList.add('hidden');
                    qrContainer.classList.add('hidden');
                    hostQuestionDisplay.classList.add('hidden');
                    hostResults.classList.remove('hidden');
                    if (hostViewHeading) hostViewHeading.classList.remove('hidden');
                    displayLeaderboard();
                } else if (quizState.isQuestionActive || (quizState.currentQuestionIndex > 0 && quizState.currentQuestionIndex < quizState.shuffledQuestions.length)) {
                    hostSetup.classList.add('hidden');
                    qrContainer.classList.add('hidden');
                    hostResults.classList.add('hidden');
                    hostQuestionDisplay.classList.remove('hidden');
                    if (hostViewHeading) hostViewHeading.classList.add('hidden'); // Hide "Quiz hosten" heading
                    // Re-render current question details if returning to view
                    const currentQuestion = quizState.shuffledQuestions[quizState.currentQuestionIndex];
                    currentQuestionTextEl.textContent = currentQuestion.question;
                    displayHostOptions(currentQuestion.shuffledOptions || currentQuestion.options, []); // Use shuffled if available
                    questionCounterEl.textContent = `Frage ${quizState.currentQuestionIndex + 1} von ${quizState.shuffledQuestions.length}`;
                    answersCount.textContent = quizState.answersReceived.toString();
                    totalPlayers.textContent = Object.values(quizState.players).filter(p => p.id !== hostPlayerId).length.toString(); // Only count non-host players
                    if (quizState.currentQuestionIndex < quizState.shuffledQuestions.length - 1) showNextBtn.classList.remove('hidden');
                    else showResultsBtn.classList.remove('hidden');
                } else { // Room is open, but quiz not active, show QR container
                    hostSetup.classList.add('hidden');
                    qrContainer.classList.remove('hidden');
                    if (hostViewHeading) hostViewHeading.classList.remove('hidden'); // Show "Quiz hosten" heading
                    const currentJoinUrl = updateJoinLink(hostRoomId); // Get the current join URL
                    generateQRCode(currentJoinUrl); // Generate QR with the full URL
                    roomIdElement.textContent = quizState.roomId || 'N/A';
                }
            } else { // Default: show setup if no room instance
                hostSetup.classList.remove('hidden');
                qrContainer.classList.add('hidden');
                hostQuestionDisplay.classList.add('hidden');
                hostResults.classList.add('hidden');
                if (hostViewHeading) hostViewHeading.classList.remove('hidden'); // Show "Quiz hosten" heading
            }


            /**
             * Renders the list of added questions in the host setup view.
             */
            function renderQuestionsList() {
                questionsContainer.innerHTML = '';
                if (quizState.questions.length === 0) {
                    questionsContainer.innerHTML = '<p>Noch keine Fragen hinzugefügt</p>';
                    startQuizBtn.classList.add('hidden');
                    return;
                }

                quizState.questions.forEach((q, index) => {
                    const item = document.createElement('div');
                    item.className = 'question-item';
                    const correctIndices = q.correct.map(i => i + 1).join(', ');
                    item.innerHTML = `
                        <p><strong>F${index + 1}:</strong> ${q.question}</p>
                        <p><strong>Optionen:</strong> ${q.options.join('; ')}</p>
                        <p><strong>Richtige Option(en):</strong> ${correctIndices}</p>
                        <button class="btn remove-question" data-index="${index}">Entfernen</button>
                    `;
                    questionsContainer.appendChild(item);
                });

                document.querySelectorAll('.remove-question').forEach(button => {
                    button.onclick = (e) => {
                        const index = parseInt(e.target.getAttribute('data-index'));
                        quizState.questions.splice(index, 1);
                        renderQuestionsList();
                    };
                });

                startQuizBtn.classList.remove('hidden');
            }

            /**
             * Initializes Supabase for the host, creates a room, and sets up subscriptions.
             */
            async function initHostSupabase(isResuming = false) {
                if (!isResuming) {
                    // Generate a random 4-character alphanumeric room code
                    const rawGeneratedId = generateAlphanumericId(4);
                    hostRoomId = rawGeneratedId; // Store the raw ID for Supabase
                    quizState.roomId = rawGeneratedId.substring(0, 2) + ' ' + rawGeneratedId.substring(2, 4); // Store formatted for display
                    hostPlayerId = `host-${generateAlphanumericId(12)}`; // Unique ID for the host player
                }

                try {
                    if (!isResuming) {
                        // Insert room into Supabase
                        const { data: roomData, error: roomError } = await supabaseClient
                            .from('rooms')
                            .insert([{
                                id: hostRoomId,
                                current_question_index: quizState.currentQuestionIndex,
                                quiz_state: {
                                    is_active: false,
                                    question_duration: quizState.questionDuration,
                                    status: 'running'
                                },
                                host_player_id: hostPlayerId
                            }]);
                        if (roomError) throw roomError;
                        console.log('Room created in Supabase:', roomData);

                        // Insert host as a player
                        const { error: hostPlayerError } = await supabaseClient
                            .from('players')
                            .insert([{
                                id: hostPlayerId,
                                room_id: hostRoomId,
                                name: 'Host',
                                score: 0,
                                is_connected: true
                            }]);
                        if (hostPlayerError) throw hostPlayerError;
                        quizState.players[hostPlayerId] = { id: hostPlayerId, name: 'Host', score: 0, currentAnswer: [], answerTime: null };
                    } else {
                        // We are resuming. IDs and state are already loaded.
                        // Just need to update our connection status.
                        await supabaseClient.from('players').update({ is_connected: true }).eq('id', hostPlayerId);
                    }

                    // Subscribe to player changes in this room
                    hostPlayersSubscription = supabaseClient
                        .channel(`players_in_room_${hostRoomId}`)
                        .on('postgres_changes', { event: '*', schema: 'public', table: 'players', filter: `room_id=eq.${hostRoomId}` }, payload => {
                            if (payload.eventType === 'INSERT') {
                                if (payload.new.id !== hostPlayerId) {
                                    console.log('New player joined:', payload.new);
                                    quizState.players[payload.new.id] = { id: payload.new.id, name: payload.new.name, score: payload.new.score, currentAnswer: [], answerTime: null };
                                    updatePlayersList();
                                }
                            } else if (payload.eventType === 'UPDATE') {
                                if (payload.new.id !== hostPlayerId) {
                                    handlePlayerData(payload.new);
                                }
                            } else if (payload.eventType === 'DELETE') {
                                console.log('Player disconnected (deleted):', payload.old.id);
                                if (quizState.players[payload.old.id]) {
                                    delete quizState.players[payload.old.id];
                                    updatePlayersList();
                                    const nonHostPlayers = Object.values(quizState.players).filter(p => p.id !== hostPlayerId);
                                    if (quizState.isQuestionActive && quizState.answersReceived >= nonHostPlayers.length) {
                                        endQuestion();
                                    }
                                }
                            }
                        })
                        .subscribe();

                    // Get initial players list
                    await updatePlayersList();

                    // Initialize broadcast channel for this room
                    hostSupabaseChannel = supabaseClient.channel(`quiz_room_${hostRoomId}`);
                    hostSupabaseChannel.subscribe((status) => {
                        if (status === 'SUBSCRIBED') {
                            console.log('Host subscribed to broadcast channel:', `quiz_room_${hostRoomId}`);
                            if (!isResuming) {
                                const sessionToSave = { roomId: hostRoomId, playerId: hostPlayerId, state: quizState };
                                localStorage.setItem(HOST_STORAGE_KEY, JSON.stringify(sessionToSave));
                                hostSetup.classList.add('hidden');
                                qrContainer.classList.remove('hidden');
                                roomIdElement.textContent = quizState.roomId;
                                const currentJoinUrl = updateJoinLink(hostRoomId);
                                generateQRCode(currentJoinUrl);
                                if (hostViewHeading) hostViewHeading.classList.remove('hidden');
                            }
                        } else if (status === 'CHANNEL_ERROR') {
                            console.error('Host channel error:', status);
                            showMessage('Fehler beim Verbinden mit dem Quiz-Raum. Bitte versuche es erneut.', 'error');
                            resetHostStateAndUI();
                        }
                    });

                } catch (error) {
                    console.error('Error initializing host Supabase:', error);
                    showMessage(`Fehler beim Starten des Hosts: ${error.message}. Bitte überprüfe deine Supabase-Konfiguration und versuche es erneut.`, 'error');
                    resetHostStateAndUI();
                }
            }

            /**
             * Handles data received from connected players (via Supabase database updates).
             */
            function handlePlayerData(playerData) {
                const playerId = playerData.id;
                console.log('Host received player data update from', playerId, playerData);

                // Ensure the player exists in our local state
                if (!quizState.players[playerId]) {
                    if (playerId !== hostPlayerId) {
                        quizState.players[playerId] = { id: playerId, name: playerData.name, score: playerData.score || 0, currentAnswer: [], answerTime: null };
                        updatePlayersList();
                    }
                }
                
                if (playerData.is_connected && quizState.players[playerId]) {
                    quizState.players[playerId].name = playerData.name; // Update name in case it changed
                }

                if (!quizState.isQuestionActive) {
                    return;
                }

                const hasAnsweredCurrentQuestion = quizState.players[playerId].currentAnswer &&
                                                   quizState.players[playerId].currentAnswer.length > 0;

                if (playerData.last_answer_data && !hasAnsweredCurrentQuestion) {
                    quizState.answersReceived++;
                    const answerReceiveTime = playerData.last_answer_time ? new Date(playerData.last_answer_time).getTime() : Date.now();
                    const timeTaken = (answerReceiveTime - hostQuestionStartTime) / 1000; // Time in seconds
                    quizState.players[playerId].answerTime = timeTaken;
                    quizState.players[playerId].currentAnswer = playerData.last_answer_data; // Store the new answer
                    answersCount.textContent = quizState.answersReceived.toString();

                    // Check if all *non-host* players have answered
                    const nonHostPlayers = Object.values(quizState.players).filter(p => p.id !== hostPlayerId && p.is_connected);
                    if (quizState.answersReceived >= nonHostPlayers.length) {
                        endQuestion();
                    }
                }
            }

            /**
             * Updates the displayed list of connected players and player count.
             */
            async function updatePlayersList() {
                if (!hostRoomId) return;
                try {
                    const { data: players, error } = await supabaseClient
                        .from('players')
                        .select('id, name, score, is_connected')
                        .eq('room_id', hostRoomId);

                    if (error) throw error;

                    const nonHostPlayers = players.filter(p => p.id !== hostPlayerId);
                    const connectedPlayerCount = nonHostPlayers.filter(p => p.is_connected).length;

                    playerCountElement.textContent = connectedPlayerCount.toString();
                    totalPlayers.textContent = connectedPlayerCount.toString();

                    playersList.innerHTML = '';
                    nonHostPlayers.forEach(p => {
                        const i = document.createElement('div');
                        i.className = 'player-item';
                        i.textContent = p.name + (p.is_connected ? '' : ' (getrennt)');
                        if (!p.is_connected) i.style.opacity = '0.5';
                        playersList.appendChild(i);
                        // Update local state
                        if (quizState.players[p.id]) {
                            quizState.players[p.id].is_connected = p.is_connected;
                        }
                    });

                    startQuestionsBtn.classList.toggle('hidden', connectedPlayerCount === 0);
                } catch (error) {
                    console.error('Error updating players list from Supabase:', error);
                }
            }

            /**
             * Generates and displays a QR code for the given URL.
             * @param {string} url - The URL to encode in the QR code.
             */
            function generateQRCode(url) {
                qrcodeElement.innerHTML = ''; // Clear previous QR code
                if (typeof QRCode === 'undefined') {
                    console.error("QR-Code-Bibliothek nicht geladen.");
                    qrcodeElement.innerHTML = `<p style="color:red;">QR-Code-Bibliothek nicht geladen. URL: ${url}</p>`;
                    return;
                }
                try {
                    new QRCode(qrcodeElement, {
                        text: url, // Encode the full URL
                        width: 240, // Increased size for initial display
                        height: 240,
                        colorDark : "#000000",
                        colorLight : "#ffffff",
                        correctLevel : QRCode.CorrectLevel.H // High error correction for complex URLs
                    });
                } catch (e) {
                    console.error("QR Code generation error:", e);
                    qrcodeElement.innerHTML = `<p style="color:red;">Fehler beim Generieren des QR-Codes. URL: ${url}</p>`;
                }
            }

             /**
              * Updates the join link to include the host's Peer ID.
              * @param {string} roomId - The Supabase room ID (4-digit alphanumeric code).
              * @returns {string} The full join URL.
              */
            function updateJoinLink(roomId) {
                // Correctly construct the URL by taking the base path and appending the query parameter
                const baseUrl = window.location.origin + window.location.pathname.split('?')[0];
                const joinUrl = `${baseUrl}?host=${roomId}`;
                joinLinkElement.href = joinUrl;
                // Display the full URL in the link text
                joinLinkElement.textContent = joinUrl;

                joinLinkModalElement.href = joinUrl;
                joinLinkModalElement.textContent = joinUrl; // Also update modal link text

                return joinUrl; // Return the URL for QR code generation
            }


            /**
             * Starts a new question round on the host side.
             */
            async function startQuestion() {
                if (quizState.currentQuestionIndex >= quizState.shuffledQuestions.length) {
                    await showFinalResults();
                    return;
                }

                const currentQuestion = quizState.shuffledQuestions[quizState.currentQuestionIndex];
                quizState.answersReceived = 0;
                quizState.isQuestionActive = true;
                hostQuestionStartTime = Date.now();

                // Prepare shuffled options and correct indices for this question
                const optionObjects = currentQuestion.options.map((text, index) => ({ text, originalIndex: index }));
                shuffleArray(optionObjects); // Shuffle the options
                const shuffledOptions = optionObjects.map(obj => obj.text);
                const shuffledCorrectIndices = currentQuestion.correct.map(originalIdx =>
                    optionObjects.findIndex(obj => obj.originalIndex === originalIdx)
                );

                // Store shuffled options and correct indices in the current question object
                currentQuestion.shuffledOptions = shuffledOptions;
                currentQuestion.shuffledCorrect = shuffledCorrectIndices;

                // Reset player answers for the new question in local state and in DB
                for (const p of Object.values(quizState.players)) {
                    p.currentAnswer = [];
                    p.answerTime = null;
                    if (p.id !== hostPlayerId) { // Don't reset host's own entry
                        try {
                            await supabaseClient.from('players').update({ last_answer_data: [], last_answer_time: null }).eq('id', p.id);
                        } catch (error) {
                            console.error(`Error resetting player ${p.name}'s answer:`, error);
                        }
                    }
                }


                currentQuestionTextEl.textContent = currentQuestion.question;
                // Display options on host side WITHOUT correct indicators initially
                displayHostOptions(shuffledOptions, []); // Use shuffled options for display
                questionCounterEl.textContent = `Frage ${quizState.currentQuestionIndex + 1} von ${quizState.shuffledQuestions.length}`;
                answersCount.textContent = '0';
                const nonHostPlayersCount = Object.values(quizState.players).filter(p => p.id !== hostPlayerId && p.is_connected).length;
                totalPlayers.textContent = nonHostPlayersCount.toString();

                showNextBtn.classList.add('hidden');
                showResultsBtn.classList.add('hidden');
                hostScoreboardEl.classList.add('hidden'); // Hide scoreboard while question is active
                if (hostViewHeading) hostViewHeading.classList.add('hidden'); // Hide "Quiz hosten" heading

                startTimer(quizState.questionDuration); // Use host-defined duration
                await sendQuestionToPlayers(currentQuestion); // Pass the question object which now contains shuffled data
            }

            /**
             * Displays the question options on the host side.
             * @param {string[]} options - An array of option strings (already shuffled if applicable).
             * @param {number[]} [correctIndices=[]] - An optional array of indices for correct answers (already re-mapped if applicable).
             * @param {number[]} [optionCounts=[]] - An optional array of counts for each option selected by players.
             */
            function displayHostOptions(options, correctIndices = [], optionCounts = []) {
                 hostCurrentOptionsEl.innerHTML = '';
                 const correctSet = new Set(correctIndices);
                 options.forEach((option, index) => {
                     const li = document.createElement('li');
                     let optionText = option;
                     if (optionCounts && optionCounts[index] !== undefined) {
                         optionText += ` (${optionCounts[index]}x gewählt)`;
                     }
                     li.textContent = optionText;
                     if (correctSet.has(index)) {
                         li.classList.add('correct');
                     }
                     hostCurrentOptionsEl.appendChild(li);
                 });
            }


            /**
             * Sends question data to all connected players via Supabase Broadcast.
             * @param {Object} question - The question object to send (now contains shuffled options and correct indices).
             */
            async function sendQuestionToPlayers(question) {
                const qData = {
                    type: 'question',
                    question: question.question,
                    options: question.shuffledOptions, // Send shuffled options
                    correct: question.shuffledCorrect, // Send re-mapped correct indices
                    index: quizState.currentQuestionIndex,
                    total: quizState.shuffledQuestions.length,
                    startTime: hostQuestionStartTime, // Send start time for player timer/scoring
                    duration: quizState.questionDuration // Send duration to players
                };
                try {
                    // Update room state in DB
                    await supabaseClient
                        .from('rooms')
                        .update({
                            current_question_index: quizState.currentQuestionIndex,
                            quiz_state: { is_active: true, question_duration: quizState.questionDuration, status: 'running' }
                        })
                        .eq('id', hostRoomId);

                    // Broadcast question to players
                    await hostSupabaseChannel.send({
                        type: 'broadcast',
                        event: 'quiz_event',
                        payload: qData
                    });
                    console.log('Question broadcasted:', qData);
                } catch (error) {
                    console.error('Error sending question via Supabase:', error);
                    showMessage('Fehler beim Senden der Frage. Bitte überprüfe deine Supabase-Verbindung.', 'error');
                }
            }

            /**
             * Starts the timer for the current question.
             * @param {number} durationSeconds - The total duration of the timer in seconds.
             */
            function startTimer(durationSeconds) {
                timerBar.style.width = '100%';
                if (hostTimerInterval) clearInterval(hostTimerInterval);

                const totalDurationMs = durationSeconds * 1000;
                const timerStartTime = Date.now();

                hostTimerInterval = setInterval(() => {
                     const elapsed = Date.now() - timerStartTime;
                     const remaining = Math.max(0, totalDurationMs - elapsed);
                     timerBar.style.width = `${(remaining / totalDurationMs) * 100}%`;

                    if (remaining <= 0) {
                        endQuestion();
                    }
                }, 100); // Update every 100ms
            }

            /**
             * Ends the current question round, calculates scores, and displays results.
             */
            async function endQuestion() {
                if (!quizState.isQuestionActive) return;

                if (hostTimerInterval) {
                    clearInterval(hostTimerInterval);
                    hostTimerInterval = null;
                }

                quizState.isQuestionActive = false;

                // Calculate option counts for display on host side
                const currentQuestion = quizState.shuffledQuestions[quizState.currentQuestionIndex];
                const optionCounts = Array(currentQuestion.shuffledOptions.length).fill(0);
                Object.values(quizState.players).filter(p => p.id !== hostPlayerId).forEach(p => {
                    if (p.currentAnswer && Array.isArray(p.currentAnswer)) {
                        p.currentAnswer.forEach(ansIndex => {
                            if (optionCounts[ansIndex] !== undefined) {
                                optionCounts[ansIndex]++;
                            }
                        });
                    }
                });

                // Display correct answers and counts on the host side
                displayHostOptions(currentQuestion.shuffledOptions, currentQuestion.shuffledCorrect, optionCounts);


                calculateScores();
                await sendResultsToPlayers();

                displayCurrentScoreboard(); // Display the scoreboard

                if (quizState.currentQuestionIndex < quizState.shuffledQuestions.length - 1) {
                    showNextBtn.classList.remove('hidden');
                    showResultsBtn.classList.add('hidden');
                } else {
                    showNextBtn.classList.add('hidden');
                    showResultsBtn.classList.remove('hidden');
                }
            }

            /**
             * Calculates scores for the current question based on correctness and time taken.
             */
            function calculateScores() {
                const currentQ = quizState.shuffledQuestions[quizState.currentQuestionIndex]; // Use shuffled questions
                const correctSet = new Set(currentQ.shuffledCorrect); // Use shuffled correct indices
                const totalQuestionTime = quizState.questionDuration; // Use host-defined duration
                const numQuestions = quizState.shuffledQuestions.length;

                const basePointsFirst = 100;
                const basePointsLast = 300;
                let currentQuestionBasePoints = basePointsFirst;

                if (numQuestions > 1) {
                    const pointsIncreasePerQuestion = (basePointsLast - basePointsFirst) / (numQuestions - 1);
                    currentQuestionBasePoints = basePointsFirst + (quizState.currentQuestionIndex * pointsIncreasePerQuestion);
                }
                // If only one question, it gets basePointsFirst (100)
                // If 2 questions, 1st gets 100, 2nd gets 300. (200 increase / 1 interval = 200 per question)
                // If 3 questions, 1st gets 100, 2nd gets 200, 3rd gets 300. (200 increase / 2 intervals = 100 per question)


                Object.values(quizState.players).forEach(p => {
                    if (p.id === hostPlayerId) return; // Skip host for scoring

                    if (p.currentAnswer && p.currentAnswer.length > 0) {
                        const playerAnsSet = new Set(p.currentAnswer);

                        let isCompletelyCorrect = correctSet.size === playerAnsSet.size &&
                                        [...playerAnsSet].every(item => correctSet.has(item));

                        if (isCompletelyCorrect) {
                            // Score = Base Points + (Time Remaining / Total Time) * Bonus Points
                            const timeTaken = p.answerTime !== null ? p.answerTime : totalQuestionTime; // Use max time if no answer time recorded
                            const timeRemaining = Math.max(0, totalQuestionTime - timeTaken);
                            const timeBonus = (timeRemaining / totalQuestionTime) * (currentQuestionBasePoints * 0.5); // Bonus proportional to question value

                            p.score += currentQuestionBasePoints + timeBonus;
                        }
                    }
                });
            }

            /**
             * Sends results of the current question to all players via Supabase Broadcast.
             */
            async function sendResultsToPlayers() {
                const currentQ = quizState.shuffledQuestions[quizState.currentQuestionIndex]; // Use shuffled questions
                const isFinalQ = quizState.currentQuestionIndex === quizState.shuffledQuestions.length - 1;

                const leaderboardData = getLeaderboardData(); // Get latest leaderboard for results

                for (const p of Object.values(quizState.players)) {
                    if (p.id === hostPlayerId) continue; // Don't update host's score in DB for players

                    // Update player score in DB
                    try {
                        await supabaseClient
                            .from('players')
                            .update({ score: p.score })
                            .eq('id', p.id);
                    } catch (error) {
                        console.error(`Error updating player ${p.name}'s score in Supabase:`, error);
                    }
                }

                // Broadcast result to all players after all scores are updated in DB
                const resData = {
                    type: 'result',
                    correct: currentQ.shuffledCorrect, // Send shuffled correct indices
                    isFinal: isFinalQ,
                    options: currentQ.shuffledOptions, // Send shuffled options to player for result display
                    leaderboard: leaderboardData // Include leaderboard for final results
                };

                try {
                    await hostSupabaseChannel.send({
                        type: 'broadcast',
                        event: 'quiz_event',
                        payload: resData
                    });
                    console.log('Results broadcasted.');
                } catch (error) {
                    console.error('Error broadcasting results via Supabase:', error);
                    showMessage('Fehler beim Senden der Ergebnisse. Bitte überprüfe deine Supabase-Verbindung.', 'error');
                }
            }

             /**
              * Displays the current scoreboard (top 10) on the host side.
              */
            function displayCurrentScoreboard() {
                const sortedPlayers = getLeaderboardData(); // This function already filters out the host
                scoreboardListEl.innerHTML = '';
                hostScoreboardEl.classList.remove('hidden');

                const topPlayers = sortedPlayers.slice(0, 10);

                if (topPlayers.length === 0) {
                    scoreboardListEl.innerHTML = '<li>Noch keine Spieler.</li>';
                    return;
                }

                topPlayers.forEach((p, idx) => {
                    const li = document.createElement('li');
                    li.className = 'scoreboard-item';
                    if (idx === 0) li.classList.add('rank-1');
                    else if (idx === 1) li.classList.add('rank-2');
                    else if (idx === 2) li.classList.add('rank-3');
                    li.innerHTML = `<span>${idx + 1}. ${p.name}</span><span>${Math.round(p.score)} Punkte</span>`;
                    scoreboardListEl.appendChild(li);
                });
            }


            /**
             * Shows the final results leaderboard on the host side.
             */
            async function showFinalResults() {
                hostQuestionDisplay.classList.add('hidden');
                hostResults.classList.remove('hidden'); // Ensure host results view is shown
                if (hostViewHeading) hostViewHeading.classList.remove('hidden'); // Show "Quiz hosten" heading

                displayLeaderboard();

                try {
                    const { data: roomData, error } = await supabaseClient.from('rooms').select('quiz_state').eq('id', hostRoomId).single();
                    if (error) throw error;
                    const finalQuizState = { ...roomData.quiz_state, is_active: false, status: 'ended' };
                    await supabaseClient.from('rooms').update({ quiz_state: finalQuizState }).eq('id', hostRoomId);
                    quizState.quiz_state = finalQuizState; // Update local state as well
                } catch (e) {
                    console.error("Error marking quiz as ended in DB", e);
                }
            }

            /**
             * Retrieves and sorts player data for the leaderboard.
             * @returns {Array<Object>} Sorted array of player objects with name and score.
             */
            function getLeaderboardData() {
                return Object.values(quizState.players)
                    .filter(p => p.id !== hostPlayerId) // Filter out the host
                    .map(p => ({ name: p.name, score: p.score }))
                    .sort((a, b) => b.score - a.score);
            }

            /**
             * Displays the final leaderboard on the host side.
             */
            function displayLeaderboard() {
                const sortedPlayers = getLeaderboardData(); // This function already filters out the host
                leaderboard.innerHTML = '';

                if (sortedPlayers.length === 0) {
                    leaderboard.innerHTML = '<p>Noch keine Spieler in der Rangliste.</p>';
                    return;
                }

                sortedPlayers.forEach((p, idx) => {
                    const i = document.createElement('div');
                    i.className = 'leaderboard-item';
                    if (idx === 0) i.classList.add('rank-1');
                    else if (idx === 1) i.classList.add('rank-2');
                    else if (idx === 2) i.classList.add('rank-3');
                    i.innerHTML = `<span>${idx + 1}. ${p.name}</span><span>${Math.round(p.score)} Punkte</span>`;
                    leaderboard.appendChild(i);
                });
            }

            /**
             * Resets the host's state and UI to the initial setup form.
             */
            async function resetHostStateAndUI() {
                localStorage.removeItem(HOST_STORAGE_KEY);
                // Unsubscribe from Supabase channels
                if (hostSupabaseChannel) {
                    await supabaseClient.removeChannel(hostSupabaseChannel);
                    hostSupabaseChannel = null;
                }
                if (hostPlayersSubscription) {
                    await supabaseClient.removeChannel(hostPlayersSubscription);
                    hostPlayersSubscription = null;
                }

                hostGlobalQuizState = null;
                isHostInitialized = false;
                hostRoomId = null;
                hostPlayerId = null;

                fileStatus.textContent = '';
                if(jsonFileInput) jsonFileInput.value = '';
                hostResults.classList.add('hidden');
                hostQuestionDisplay.classList.add('hidden');
                qrContainer.classList.add('hidden');
                hostSetup.classList.remove('hidden');
                document.getElementById('role-selection').classList.remove('hidden'); // Show role selection again
                if (hostViewHeading) hostViewHeading.classList.remove('hidden'); // Show "Quiz hosten" heading
                initializeHostFeatures(); // Re-initialize to reset UI fully
            }
        }

        // --- Player State & Initialization Flag ---
        let playerSupabaseChannel = null; // Supabase Broadcast Channel for player to receive messages
        let playerRoomId = null;
        let playerCurrentId = null; // The player's unique ID
        let isPlayerInitialized = false;
        let playerTimerInterval = null;
        let playerCurrentQuestionOptions = [];
        let selectedAnswers = []; // This will hold the player's selected answers for the current question
        let playerScore = 0;
        let playerQuestionStartTime = null;

        // Function to trigger confetti animation
        function triggerConfetti() {
            const confettiContainer = document.getElementById('confetti-container');
            if (!confettiContainer) {
                console.warn("Confetti-Container nicht gefunden.");
                return;
            }

            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4CAF50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];
            const numConfetti = 50; // Number of confetti pieces

            for (let i = 0; i < numConfetti; i++) {
                const piece = document.createElement('div');
                piece.className = 'confetti-piece';
                piece.style.left = `${Math.random() * 100}vw`; // Random horizontal position
                piece.style.top = `${-20 - Math.random() * 100}px`; // Start above viewport
                piece.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                piece.style.animationDelay = `${Math.random() * 0.5}s`; // Stagger animation
                piece.style.animationDuration = `${2 + Math.random() * 2}s`; // Random duration

                confettiContainer.appendChild(piece);

                // Remove the piece after its animation ends
                piece.addEventListener('animationend', () => {
                    piece.remove();
                });
            }
        }

        /**
         * Initializes all features and event listeners for the player role.
         */
        function initializePlayerFeatures() {
            if (isPlayerInitialized) return; // Prevent re-initialization
            console.log("Initializing Player Features.");

            // --- Player-specific functions defined inside to create a closure ---

            async function resumePlayerSession(sessionData) {
                console.log("Resuming player session:", sessionData);
                playerRoomId = sessionData.roomId;
                playerCurrentId = sessionData.playerId;
                const playerName = sessionData.name;

                // Show waiting room while we reconnect
                document.getElementById('join-form').classList.add('hidden');
                waitingRoom.classList.remove('hidden');
                waitingMessage.textContent = `Versuche, Raum ${playerRoomId} wieder beizutreten...`;

                await initPlayerSupabase(playerRoomId, playerName, true);
            }

            async function fetchAndDisplayCurrentPlayerState() {
                try {
                    // Fetch the latest room and player state from the database
                    const { data: roomData, error: roomError } = await supabaseClient
                        .from('rooms')
                        .select('quiz_state, current_question_index')
                        .eq('id', playerRoomId)
                        .single();

                    const { data: playerData, error: playerError } = await supabaseClient
                        .from('players')
                        .select('score')
                        .eq('id', playerCurrentId)
                        .single();

                    if (roomError || playerError) throw roomError || playerError;

                    playerScore = playerData.score || 0;
                    const quizState = roomData.quiz_state;

                    // Hide all views first
                    [playerQuestionView, playerResultView, waitingRoom, playerFinalResultView].forEach(v => v.classList.add('hidden'));

                    if (quizState.status === 'ended') {
                        const { data: players, error: playersError } = await supabaseClient
                            .from('players').select('name, score').eq('room_id', playerRoomId).neq('id', `host-${playerRoomId}`).order('score', { ascending: false });
                        if (playersError) throw playersError;
                        displayFinalResult({ leaderboard: players });
                    } else if (quizState.is_active) {
                        playerResultView.classList.remove('hidden');
                        resultDisplay.innerHTML = "Ein Quiz läuft gerade. Bitte warte auf die nächste Frage.";
                        playerScoreEl.textContent = Math.round(playerScore);
                        waitingForNext.textContent = 'Warten auf nächste Frage...';
                    } else {
                        waitingRoom.classList.remove('hidden');
                        waitingMessage.textContent = 'Du bist dem Raum wieder beigetreten. Warte auf den Host...';
                    }
                } catch (error) {
                    console.error("Error fetching player state on resume:", error);
                    showMessage("Konnte den Quiz-Status nicht abrufen. Warte auf den Host.", "error");
                    waitingRoom.classList.remove('hidden');
                    waitingMessage.textContent = 'Fehler beim Wiederverbinden. Warte auf den Host...';
                }
            }

            /**
             * Initializes Supabase for the player and joins a room.
             */
            async function initPlayerSupabase(hostRoomId, pName, isResuming = false) {
                playerRoomId = hostRoomId;

                joinForm.classList.add('hidden');
                waitingRoom.classList.remove('hidden');
                waitingMessage.textContent = `Verbinde mit Raum ${playerRoomId}...`;

                try {
                    const { data: room, error: roomError } = await supabaseClient.from('rooms').select('id, quiz_state').eq('id', playerRoomId).single();

                    if (roomError || !room) {
                        showMessage('Raum nicht gefunden oder Fehler beim Abrufen des Raums. Bitte überprüfe den Code.', 'error');
                        localStorage.removeItem(PLAYER_STORAGE_KEY);
                        resetPlayerStateAndUI();
                        return;
                    }
                    
                    if (room.quiz_state?.status === 'ended' && !isResuming) {
                        showMessage('Dieses Quiz wurde bereits beendet.', 'info');
                        resetPlayerStateAndUI();
                        return;
                    }

                    if (isResuming) {
                        await supabaseClient.from('players').update({ is_connected: true }).eq('id', playerCurrentId);
                    } else {
                        playerCurrentId = `player-${generateAlphanumericId(12)}`;
                        const { error: playerInsertError } = await supabaseClient.from('players').insert([{ id: playerCurrentId, room_id: playerRoomId, name: pName, score: 0, is_connected: true }]);
                        if (playerInsertError) throw playerInsertError;
                        
                        const sessionToSave = { roomId: playerRoomId, playerId: playerCurrentId, name: pName };
                        localStorage.setItem(PLAYER_STORAGE_KEY, JSON.stringify(sessionToSave));
                    }

                    playerSupabaseChannel = supabaseClient.channel(`quiz_room_${playerRoomId}`);
                    playerSupabaseChannel.on('broadcast', { event: 'quiz_event' }, (payload) => handleHostData(payload.payload))
                        .subscribe(async (status) => {
                            if (status === 'SUBSCRIBED') {
                                console.log('Player subscribed to broadcast channel:', `quiz_room_${playerRoomId}`);
                                waitingMessage.textContent = 'Verbunden! Warte auf Host...';
                                if (isResuming) await fetchAndDisplayCurrentPlayerState();
                            } else if (status === 'CHANNEL_ERROR') {
                                console.error('Player channel error:', status);
                                showMessage('Fehler beim Verbinden mit dem Quiz-Raum. Bitte versuche es erneut.', 'error');
                                resetPlayerStateAndUI();
                            }
                        });

                } catch (error) {
                    console.error('Error initializing player Supabase:', error);
                    showMessage(`Fehler beim Beitreten des Quiz: ${error.message}.`, 'error');
                    resetPlayerStateAndUI();
                }
            }

            /**
             * Handles data received from the host (via Supabase Broadcast).
             */
            async function handleHostData(data) {
                console.log('Player received data from host:', data);
                switch (data.type) {
                    case 'question':
                        playerCurrentQuestionOptions = data.options;
                        selectedAnswers = [];
                        playerQuestionStartTime = Date.now();
                        displayQuestion(data);
                        startPlayerTimer(data.duration);
                        break;
                    case 'result':
                        const { data: dbData, error } = await supabaseClient.from('players').select('score, last_answer_data').eq('id', playerCurrentId).single();
                        if (error) {
                            console.error('Error fetching player data for result:', error);
                            displayResult(data, selectedAnswers, playerScore);
                        } else {
                            playerScore = dbData.score || 0;
                            displayResult(data, dbData.last_answer_data || [], playerScore);
                        }
                        waitingForNext.textContent = data.isFinal ? 'Warten auf Endergebnisse...' : 'Warten auf nächste Frage...';
                        if (data.isFinal) displayFinalResult(data);
                        break;
                    case 'quiz_terminated':
                        showMessage("Der Host hat das Quiz beendet.", 'info');
                        resetPlayerStateAndUI();
                        showView('role-selection');
                        break;
                }
            }

            /**
             * Starts the player's timer for the current question.
             */
            function startPlayerTimer(durationSeconds) {
                playerTimerBar.style.width = '100%';
                if (playerTimerInterval) clearInterval(playerTimerInterval);
                const totalDurationMs = durationSeconds * 1000;
                const timerStartTime = Date.now();
                playerTimerInterval = setInterval(() => {
                    const elapsed = Date.now() - timerStartTime;
                    const remaining = Math.max(0, totalDurationMs - elapsed);
                    playerTimerBar.style.width = `${(remaining / totalDurationMs) * 100}%`;
                    if (remaining <= 0) {
                        clearInterval(playerTimerInterval);
                        playerTimerInterval = null;
                        submitAnswerBtn.classList.add('hidden');
                        optionsContainer.querySelectorAll('button.option-btn').forEach(btn => btn.disabled = true);
                        if (selectedAnswers.length === 0) {
                            supabaseClient.from('players').update({ last_answer_data: [], last_answer_time: new Date().toISOString() }).eq('id', playerCurrentId);
                        }
                    }
                }, 100);
            }

            /**
             * Displays the question and options for the player.
             */
            function displayQuestion(qData) {
                waitingRoom.classList.add('hidden');
                playerResultView.classList.add('hidden');
                playerQuestionView.classList.remove('hidden');
                playerQuestionTextEl.textContent = qData.question;
                playerQuestionCounterEl.textContent = `Frage ${qData.index + 1} von ${qData.total}`;
                optionsContainer.innerHTML = '';
                selectedAnswers = [];
                qData.options.forEach((option, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'option-btn';
                    btn.textContent = option;
                    btn.dataset.index = index;
                    btn.addEventListener('click', () => {
                        const optIdx = parseInt(btn.dataset.index);
                        const pos = selectedAnswers.indexOf(optIdx);
                        if (pos > -1) {
                            selectedAnswers.splice(pos, 1);
                            btn.classList.remove('selected');
                        } else {
                            selectedAnswers.push(optIdx);
                            btn.classList.add('selected');
                        }
                        submitAnswerBtn.classList.toggle('hidden', selectedAnswers.length === 0);
                    });
                    optionsContainer.appendChild(btn);
                });
                submitAnswerBtn.classList.add('hidden');
                submitAnswerBtn.disabled = false;
                optionsContainer.querySelectorAll('button.option-btn').forEach(btn => {
                    btn.disabled = false;
                    btn.classList.remove('correct-answer', 'incorrect-answer', 'selected');
                });
            }

            /**
             * Displays the result of the just-answered question.
             */
            function displayResult(rData, playerAnswer, currentScore) {
                playerQuestionView.classList.add('hidden');
                playerResultView.classList.remove('hidden');
                const playerAnsSet = new Set(playerAnswer || []);
                const correctSet = new Set(rData.correct);
                let isCorrect = correctSet.size === playerAnsSet.size && [...playerAnsSet].every(item => correctSet.has(item));
                let resultHtml = `Deine Antwort war <strong class="${isCorrect ? 'correct' : 'incorrect'}">${isCorrect ? 'RICHTIG!' : 'FALSCH.'}</strong>`;
                if (isCorrect) triggerConfetti();
                resultDisplay.innerHTML = resultHtml;
                playerScoreEl.textContent = Math.round(currentScore);
            }

            /**
             * Displays the final results and leaderboard.
             */
            function displayFinalResult(frData) {
                playerQuestionView.classList.add('hidden');
                playerResultView.classList.add('hidden');
                waitingRoom.classList.add('hidden');
                playerFinalResultView.classList.remove('hidden');
                finalScoreEl.textContent = Math.round(playerScore);
                playerLeaderboardContainer.innerHTML = '';
                if (frData.leaderboard) {
                    const lbDiv = document.createElement('div');
                    lbDiv.innerHTML = '<h4>Endgültige Rangliste:</h4>';
                    const ol = document.createElement('ol');
                    frData.leaderboard.forEach((p, idx) => {
                        const li = document.createElement('li');
                        if (idx === 0) li.classList.add('rank-1');
                        if (idx === 1) li.classList.add('rank-2');
                        if (idx === 2) li.classList.add('rank-3');
                        li.textContent = `${idx + 1}. ${p.name}: ${Math.round(p.score)} Punkte`;
                        ol.appendChild(li);
                    });
                    lbDiv.appendChild(ol);
                    playerLeaderboardContainer.appendChild(lbDiv);
                } else {
                    playerLeaderboardContainer.innerHTML = '<p>Keine Ranglistendaten verfügbar.</p>';
                }
            }

            /**
             * Resets the player's state and UI to the initial join form.
             */
            async function resetPlayerStateAndUI() {
                localStorage.removeItem(PLAYER_STORAGE_KEY);
                if (playerSupabaseChannel) {
                    await supabaseClient.removeChannel(playerSupabaseChannel);
                    playerSupabaseChannel = null;
                }
                if (playerCurrentId) {
                    await supabaseClient.from('players').update({ is_connected: false }).eq('id', playerCurrentId);
                }
                playerScore = 0;
                selectedAnswers = [];
                playerCurrentId = null;
                isPlayerInitialized = false;
                showView('role-selection');
            }

            // --- Initialization Logic ---
            const roomCodeInput = document.getElementById('room-code-input');
            const playerNameInput = document.getElementById('player-name-input');
            const joinBtn = document.getElementById('join-btn');
            const joinForm = document.getElementById('join-form');
            const waitingRoom = document.getElementById('waiting-room');
            const waitingMessage = document.getElementById('waiting-message');
            const playerQuestionView = document.getElementById('player-question');
            const playerQuestionTextEl = document.getElementById('player-question-text');
            const playerQuestionCounterEl = document.getElementById('player-question-counter');
            const playerTimerBar = document.getElementById('player-timer-bar');
            const optionsContainer = document.getElementById('options-container');
            const submitAnswerBtn = document.getElementById('submit-answer-btn');
            const playerResultView = document.getElementById('player-result');
            const resultDisplay = document.getElementById('result-display');
            const playerScoreEl = document.getElementById('player-score');
            const waitingForNext = document.getElementById('waiting-for-next');
            const playerFinalResultView = document.getElementById('player-final-result');
            const finalScoreEl = document.getElementById('final-score');
            const playAgainBtn = document.getElementById('play-again-btn');
            const playerLeaderboardContainer = document.getElementById('player-leaderboard-container');

            const savedPlayerSession = localStorage.getItem(PLAYER_STORAGE_KEY);
            if (savedPlayerSession) {
                if (confirm("Möchten Sie versuchen, Ihrem letzten Quiz wieder beizutreten?")) {
                    const sessionData = JSON.parse(savedPlayerSession);
                    resumePlayerSession(sessionData);
                    return;
                } else {
                    localStorage.removeItem(PLAYER_STORAGE_KEY);
                    showView('role-selection');
                    return;
                }
            }

            joinBtn.addEventListener('click', async () => {
                const roomCode = roomCodeInput.value.trim().replace(/\s/g, '');
                const playerName = playerNameInput.value.trim() || 'Spieler ' + generateAlphanumericId(4);
                if (!roomCode) {
                    showMessage('Bitte gib einen Raum-Code ein.', 'error');
                    return;
                }
                await initPlayerSupabase(roomCode, playerName);
            });

            submitAnswerBtn.addEventListener('click', async () => {
                if (selectedAnswers.length === 0) {
                    showMessage('Bitte wähle mindestens eine Antwort aus.', 'info');
                    return;
                }
                submitAnswerBtn.disabled = true;
                optionsContainer.querySelectorAll('button.option-btn').forEach(btn => btn.disabled = true);
                if (playerTimerInterval) clearInterval(playerTimerInterval);
                await supabaseClient.from('players').update({ last_answer_data: selectedAnswers, last_answer_time: new Date().toISOString() }).eq('id', playerCurrentId);
            });

            playAgainBtn.addEventListener('click', () => {
                resetPlayerStateAndUI();
            });

            window.addEventListener('beforeunload', async () => {
                if (playerSupabaseChannel) await supabaseClient.removeChannel(playerSupabaseChannel);
                if (playerCurrentId) await supabaseClient.from('players').update({ is_connected: false }).eq('id', playerCurrentId);
            });

            isPlayerInitialized = true;
        }
    </script>
</body>
</html>
